#!/usr/bin/python
# -*- coding: utf-8 -*-

# (c) 2015, Matt Schreiber <schreibah () gmail.com>,
# <https://github.com/BaxterStockman>
#
# Based substantially on ini_file.py, (c) 2012, Jan-Piet Mens
# <jpmens () gmail.com>.
#
# Released under the same terms as Ansible itself, as reproduced below:
#
#   'Ansible is free software: you can redistribute it and/or modify it under
#   the terms of the GNU General Public License as published by the Free
#   Software Foundation, either version 3 of the License, or (at your option)
#   any later version.
#
#   You should have received a copy of the GNU General Public License along
#   with Ansible.  If not, see <http://www.gnu.org/licenses/>.'
#

DOCUMENTATION = '''
---
module: nginx_config
short_description: Manage C(nginx.conf)
extends_documentation_fragment: files
description:
     - Add, remove or update settings in the Nginx configuration file
       C(nginx.conf) without needing to manage the whole shebang.
     - Supports a I(batch) mode for making multiple configuration changes in
       one go.
version_added: "1.9"
options:
  dest:
    description:
      - Path to C(nginx.conf).
      - If this file does not already exist, it will be created.
    required: no
    default: C(/opt/nginx/nginx.conf)
  libdir:
    description:
      - Path to the Nginx Python libraries.
    required: no
    default: C(os.path.basename(/opt/nginx))
  section:
    description:
      - The name of a C([section]) in C(nginx.conf).
      - Will be ignored in batch mode.
    required: no
    default: null
  option:
    description:
      - The left side of an C(option = value) pair.
      - Will be ignored in batch mode and when deleting a whole section.
    required: no
    default: null
  value:
    description:
      - The right side of an C(option = value) pair
      - Will be ignored in batch mode and when deleting a whole section.
    required: no
    default: null
  settings:
    description:
      - A hash of settings that will be merged into C(nginx.conf).
      - Top-level keys are section names, (almost) everything else is a
        C(option = value) pair (see the 'Notes' section for the exception).
  state:
    description:
      - The desired state of the section, option, or hash of settings.
      - If I(state) is I(absent) and I(option) is not defined, the entire
        I(section) will be removed.
      - In batch mode, the I(settings) hash is merged recursively into any
        existing Nginx options.  No state concerning I(settings) is
        maintained between plays, so if you accidentally included C(frob=nozzle)
        somewhere in your I(settings) hash, it's going to stay in
        C(nginx.conf) until you remove it with C(state=absent), or manually.
    required: no
    default: "batch"
    choices: [ "present", "absent", "batch" ]
  backup:
    description:
      - Create a timestamped backup of the original C(nginx.conf).
    required: no
    default: "no"
    choices: [ "yes", "no" ]
notes:
  - This module uses Nginx's library code for manipulating the
    configuration file, so Nginx must be installed and its libraries must
    be readable or the module will fail to run.
  - Nginx does a fair bit of internal twiddling between (1) loading the
    configuration file into a ConfigObj object, (2) translating configuration
    file settings into its own internal database settings, and (3) merging that
    database back into the ConfigObj object prior to writing out a new
    configuration file.  This twiddling includes, but is far from limited to,
    adding default values for the various C([categories]).  Rather than try to
    re-implement Nginx's internal logic, this module instead tries its
    hardest to rely on Nginx's own library routines.  But because so much of
    the munging logic just described occurs within subroutines that
    inextricably involve reading from and writing to disk, this module is very
    heavy on the I/O -- every C(nginx_config) task involves at least two
    reads and two writes of C(nginx.conf).  Batch mode helps cut down on this.
  - Final caution: this module does not preserve comments in the configuration
    file.

requirements: [ nginx ]

author: Matt Schreiber U(https://github.com/BaxterStockman), based on Jan-Piet
        Miens' work on the M(ini_file) module.
'''

EXAMPLES = '''
# Change value of port and https_port in the [misc] section
- nginx_config:
    dest: "/opt/nginx/nginx.conf"
    settings:
      misc:
        port: 9090
        https_port: 9095

# Delete the [growl] section
- nginx_config:
    dest: "/opt/nginx/nginx.conf"
    section: growl
    ensure: absent

# Delete the 'priority' key from the [categories][[tv]] section
- nginx_config:
    dest: "/opt/nginx/nginx.conf"
    section: categories
    option:
      tv: priority
    ensure: absent
'''

import copy
import os
import shutil
import sys
import tempfile

from utils import nginxparser

# ==============================================================
# NginxConfigWrapper

class NginxConfigWrapper(object):
    def __init__(self, module, filename, state='batch', libdir=None,
                 settings=None, section=None, option=None, value=None,
                 backup=False):
        self.module = module
        self.filename = filename
        self.state = state
        self.settings = settings
        self.option = option
        self.value = value
        self.section = section
        self.backup = backup

        # Backup filename for restoration in case of error
        self.temp_filename = tempfile.mktemp()

        # Try to create a backup file, ignoring errors errors, since the source
        # file might not exist yet.
        if not os.path.exists(self.temp_filename):
            try:
                shutil.copy2(filename, self.temp_filename)
            except (OSError, IOError):
                pass
            except Exception as err:
                module.fail_json(msg="Error backing up Nginx configuration %s: %s"
                                 % (filename, str(err)))

        self.set_operation(state)

        self.validate()

    def cleanup(self, changed):
        if self.module.check_mode:
            # Try to restore backup file
            try:
                shutil.move(self.temp_filename, self.filename)
            except:
                # Assume that failure to restore the file indicates that no
                # backup was made because no file existed at the start of the
                # run.
                try:
                    os.remove(filename)
                except Exception as err:
                    self.module.fail_json(msg="Can't remove Nginx config file %s: %s"
                                          % (self.filename, str(err)))
            return changed
        else:
            if changed:
                if self.backup:
                    self.module.backup_local(filename)

                self.save_config()

            file_args = self.module.load_file_common_arguments(self.module.params)
            return self.module.set_fs_attributes_if_different(file_args, changed)

    def set_operation(self, state=None):
        if state is None:
            state = self.state

        if state == 'batch':
            self.operation = self.do_batch
        elif state == 'present':
            self.operation = self.do_present
        elif state == 'absent':
            self.operation = self.do_absent

    def validate(self):
        state = self.state

        missing = []

        if state == 'batch':
            if not isinstance(self.settings, dict):
                missing.append('settings')
        elif state == 'present' or state == 'absent':
            if self.section is None and self.option is None:
                missing.append('section', 'option')

        if missing:
            self.module.fail_json(msg="Missing required arguments: %s" %
                                  ','.join(missing))

    def run(self, *args, **kwargs):
        # Store initial config
        init_config_dict = self.get_config()

        # Execute the operation.  Write out the configuration file, then
        # reload.  This is so that Nginx can do its internal twiddling with
        # configuration values, rather than reimplement all that here.
        self.operation(*args, **kwargs)

        # Determine whether a change occurred
        changed = self.is_changed(init_config_dict, self.config)

        # Write out the configuration, if not in check_mode
        return self.cleanup(changed)

    def get_config(self, filename=None, reload=False):
        if filename is None:
            filename = self.filename

        try:
            fileobj = open(filename)
            blocks = nginxparser.load(fileobj)
            self.config = self.to_dict(blocks)
            fileobj.close()
        except Exception as err:
            self.module.fail_json(msg="Can't read Nginx config file %s: %s" %
                                (filename, str(err)))

        return self.config

    def save_config(self):
        try:
            fileobj = open(self.filename, 'w')
            blocks = self.un_dict(self.config)
            fileobj.write(nginxparser.dumps(blocks))
            fileobj.close()
        except IOError as err:
            self.module.fail_json(msg="Failed to write Nginx configuration file %s: %s"
                             % (self.filename, str(err)))

    def merge_config(self, left, right):
        ''' stolen from ansible.utils.merge_hash '''
        res_dict = dict()

        for dicts in left, right:
            for key, value in dicts.iteritems():
                if key in res_dict and isinstance(res_dict[key], dict):
                    res_dict[key] = self.merge_config(left[key], value)
                else:
                    res_dict[key] = value

        return res_dict

    def is_changed(self, left, right):
        """ Nothing more complicated ATM
        """
        return (cmp(left, right) != 0)

    def do_present(self, settings=None, section=None, option=None, value=None, config=None):
        if config is None:
            config = self.get_config()

        try:
            config[section] = self.merge_config(config[section], {option: value})
        except KeyError:
            config[section] = {option: value}

    def do_absent(self, settings=None, section=None, option=None, value=None, config=None):
        if config is None:
            config = self.get_config()

        section_obj = None
        try:
            section_obj = config[section]
        except KeyError:
            return

        if option is None:
            del config[section]
        else:
            if isinstance(option, dict):
                for key, value in option.iteritems():
                    self.do_absent(section=key, option=value, config=section_obj)
            elif hasattr(option, '__iter__'):
                for key in option:
                    self.do_absent(section=key, option=value, config=section_obj)
            elif isinstance(option, basestring):
                self.do_absent(section=option, config=section_obj)
            else:
                self.module.fail_json(msg="Don't understand how to handle option type: %s" %
                                      option.__class__.__name__)

    def do_batch(self, settings=None, section=None, option=None, value=None, config=None):
        if settings is None:
            settings = self.settings

        # Now merge the wanted settings and compare
        self.config = self.merge_config(self.get_config(), self.settings)

    def to_dict(self, caller_nested_list):
        res_dict = dict()
        nested_list = copy.deepcopy(caller_nested_list)

        for elem in nested_list:
            if isinstance(elem, list):
                if isinstance(elem[0], list):
                    if len(elem[0]) > 1:
                        key = elem[0].pop()
                        res_dict[key] = self.to_dict(elem[1])
                        if len (elem[0]) > 1:
                            res_dict[key].update({'location': elem[0][-1]})
                        else:
                            res_dict[key].update({'location': None})

                    else:
                        res_dict[elem[0][0]] = self.to_dict(elem[1])
                else:
                    if len(elem) > 2:
                        res_dict[elem[0]] = elem[1:]
                    else:
                        res_dict[elem[0]] = elem[1]

        return res_dict

    def un_dict(self, caller_res_dict):
        nested_list = list()

        res_dict = copy.deepcopy(caller_res_dict)
        for key, value in res_dict.iteritems():
            if isinstance(value, dict):
                key_list = [key]
                if 'location' in value:
                    if value['location'] is not None:
                        key_list = ['location', value['location'], key]
                    else:
                        key_list = ['location', key]
                    del(value['location'])
                nested_list.append([key_list, self.un_dict(value)])
            else:
                nested_list.append([key, value])

        return nested_list

# ==============================================================
# main

def main():
    module = AnsibleModule(
        argument_spec = dict(
            dest     = dict(required=True),
            libdir   = dict(required=False),
            settings = dict(required=False, type='dict'),
            section  = dict(required=False, type='str'),
            option   = dict(required=False),
            value    = dict(required=False),
            backup   = dict(default='no', type='bool'),
            state    = dict(default='batch', choices=['batch', 'absent', 'present'])
        ),
        add_file_common_args = True,
        supports_check_mode = True
    )

    dest = os.path.expanduser(module.params['dest'])
    libdir = None
    if module.params['libdir'] is not None:
        libdir = os.path.expanduser(module.params['libdir'])
    section = module.params['section']
    option = module.params['option']
    value = module.params['value']
    settings = module.params['settings']
    state = module.params['state']
    backup = module.params['backup']

    config = NginxConfigWrapper(module, dest, libdir=libdir, section=section,
                                option=option, value=value, settings=settings,
                                state=state, backup=backup)

    changed = config.run(section=section, option=option, value=value,
                         settings=settings)

    module.exit_json(dest=dest, changed=changed, msg="OK")

# import module snippets
from ansible.module_utils.basic import *

if __name__ == '__main__':
    main()
